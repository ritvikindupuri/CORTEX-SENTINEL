# CORTEX SENTINEL // ENGINEERING WHITEPAPER

**System:** Cortex Sentinel V2.1 (Hybrid Architecture)
**Author:** Ritvik Indupuri
**Date:** November 14, 2025
**Classification:** TECHNICAL REFERENCE

---

## 1.0 EXECUTIVE SUMMARY

Cortex Sentinel is a **Hybrid Defense Grid** designed to detect, classify, and neutralize "Agentic Breakouts" (autonomous AI operations). It addresses the security gap where traditional regex-based firewalls fail to detect semantic threats generated by Large Language Models (LLMs).

The system leverages a **Bicameral Architecture**:
1.  **The Adversary (Attacker):** Acts as the "Red Team". It uses Google Gemini (Cloud) or scripts to *write* the attack story.
2.  **The Sentinel (Defender):** Acts as the "Blue Team". It uses TensorFlow.js (Local) to *read* the story and use math to decide if it represents a threat.

---

## 2.0 SYSTEM ARCHITECTURE

The application follows a unidirectional data flow pattern, ensuring state consistency between the simulation engine and the visualization layer.

### 2.1 Architecture Diagram

```text
[ USER ] interacts with UI
   |
   v
[ THREAT HUNTER COMPONENT ]
   |
   +--- (A) GENERATION PATHWAY (The Attacker) -----------+
   |    1. User Click "Generate Log"                     |
   |    2. Check for API Key                             |
   |       |-- YES: Call Gemini 2.5 Flash (The Brain)    |
   |       |-- NO:  Call Procedural Script (Fallback)    |
   |    3. Output: Realistic JSON Log Entry              |
   +-----------------------------------------------------+
   |
   v
[ INPUT BUFFER (Terminal UI) ]
   |
   +--- (B) ANALYSIS PATHWAY (The Defender) -------------+
   |    1. User Clicks "Analyze Telemetry"               |
   |    2. Input String -> NeuralService                 |
   |    3. TENSORFLOW.JS (WebGL Backend)                 |
   |       |-- Input -> Universal Sentence Encoder       |
   |       |-- Output -> 512-Dim Vector Embedding        |
   |       |-- Math -> Dot Product vs. Threat Anchors    |
   |    4. Heuristic Checks (Regex/Pattern)              |
   |    5. Output: ThreatAnalysis Object                 |
   +-----------------------------------------------------+
   |
   v
[ APP STATE (React Context) ]
   |
   +--- Updates OPS CENTER (Dashboard Metrics)
   +--- Appends to RAW TELEMETRY (Audit Log)
   +--- Serialized to SESSION STORAGE (History)
```

---

## 3.0 COMPONENT DEEP DIVE: THE ATTACKER (GENERATOR)

This component acts as the **"Red Team"** or adversary. Its sole job is to create the data.

### 3.1 How It Works
When the user clicks **"Generate Log"**, the app calls the `generateSimulation` function in `services/gemini.ts`.

### 3.2 The Brain (Dual-Mode Engine)
The Generator has two modes of operation:

1.  **Cloud Mode (Google Gemini 2.5 Flash):**
    *   **Trigger:** Active API Key.
    *   **Behavior:** The app sends a prompt to Gemini asking it to *pretend* to be a hacker tool (like Nmap, SQLMap, or an Agentic AI).
    *   **Result:** Highly varied, context-aware, and realistic attack logs. It "hallucinates" the attack based on the prompt constraints.

2.  **Local Mode (Procedural Script):**
    *   **Trigger:** No API Key or Offline.
    *   **Behavior:** Uses a JavaScript function that acts like a "Mad Libs" engine. It creates logs using pre-defined templates, filling in the blanks with randomized IP addresses, timestamps, and user agents.
    *   **Result:** Deterministic, reliable logs that ensure the app functions perfectly without an internet connection.

### 3.3 Realism & Tradecraft Modeling
To ensure the "Solution" is valid, we model real-world Attacker Tradecraft.
*   **RedScan Protocol:** The prompt specifically instructs the AI to mimic the "RedScan" agentic behavior defined in the security report: low-latency requests, JSON headers with missing signatures, and "authorized audit" social engineering attempts.
*   **Tool Emulation:** The system does not run binaries (like Nmap) but *emulates* their output text, allowing for safe, sandbox-free testing of detection logic.

### 3.4 Attack Vector Prompt Strategies (Cloud Mode)
How Gemini is "trained" via prompt engineering for each unique vector:
*   **Reconnaissance:** Prompted to simulate `nmap` style JSON outputs, specifically focusing on port scanning behavior.
*   **Exploitation:** Prompted to simulate high-velocity API calls (`latency < 10ms`) to trigger the Velocity Guardrail.
*   **Exfiltration:** Prompted to generate large Base64 payloads to simulate Context Window Overflow attempts.
*   **Social Engineering:** Prompted to generate conversational logs where a user requests "authorized access" to test semantic analysis.

### 3.5 Procedural Template Logic (Local Mode)
When offline, the engine uses a `switch` statement to mathematically construct logs based on the selected vector:
*   **Dynamic Injection:** Calculates random IPs (`192.168.x.x`) and current ISO timestamps to ensure uniqueness.
*   **Reconnaissance Template:** Injects a hardcoded `PORT_SCAN_DETECTED` event with random port arrays `[22, 80, 443]`.
*   **Exploitation Template:** Specifically constructs a `TOOL_EXECUTION_SPIKE` event with `latency: "4ms"`. This is designed to mathematically trigger the Defender's Velocity Heuristic.
*   **RedScan Protocol Template:** Injects `auth_signature: null` to guarantee a Protocol Guardrail trigger.
*   **Exfiltration Template:** Injects `status: "TRUNCATED"` and `method: "BASE64_CHUNKED"` to simulate context window overflow.

---

## 4.0 COMPONENT DEEP DIVE: THE DEFENDER (ANALYZER)

This component acts as the **"Blue Team"** or security system. Its job is to detect threats in the data generated by the Attacker.

### 4.1 How It Works
When the user clicks **"Analyze Telemetry"**, the app calls the `analyzeThreatLog` function. This runs entirely client-side in the browser.

### 4.2 The Brain (TensorFlow.js)
The Defender uses the **Universal Sentence Encoder (USE)** running on WebGL via TensorFlow.js.

### 4.3 The Process
1.  **Input:** It takes the text log string (either generated by the Attacker OR pasted manually by the user).
2.  **Vectorization:** It feeds the text into the Neural Network, which converts the semantic meaning into a **512-dimensional vector** (a list of 512 numbers).
3.  **Comparison:** It compares this vector against **"Threat Anchors"**—definitions of bad behavior (like "malware", "injection", "overflow") that we taught it at startup.
4.  **Math:** It calculates the **Cosine Similarity** (Vector Dot Product) between the Input Vector and the Threat Anchor.
    *   `Score > 0.6` = Semantic Match (Threat).
5.  **Guardrails:** It simultaneously runs regex checks for specific patterns (like counting `MCP_TOOL_EXECUTION` > 2).
6.  **Verdict:** If the Math or the Guardrails flag the content, the Dashboard turns red.

### 4.4 MCP Guardrail Detection (Heuristics)
To detect specific "Agentic" behaviors defined in the security report, we use a Hybrid Detection Strategy.

#### A. Velocity Guardrail (Speed)
*   **Definition:** Agents execute tools faster than humanly possible.
*   **Detection Logic:**
    *   *Neural:* Similarity to anchor "high frequency rapid fire tool execution".
    *   *Heuristic:* Regex counts occurrences of `MCP_TOOL_EXECUTION`.
    *   **Threshold:** If Count > 2 in a single payload, `isBurstAttack` is set to `TRUE`, immediately flagging a CRITICAL threat.

#### B. Protocol Guardrail (Auth)
*   **Definition:** Agents attempting to bypass handshake verification.
*   **Detection Logic:**
    *   *Neural:* Similarity to anchor "missing auth signature invalid mcp header".
    *   *Heuristic:* String match for `auth_signature: null` or `INVALID_MCP_HEADER`.

#### C. Context Guardrail (Payload)
*   **Definition:** Agents attempting to hide malicious code via compression/truncation to fit context windows.
*   **Detection Logic:**
    *   *Neural:* Similarity to anchor "context window overflow truncation".
    *   *Heuristic:* String match for `TRUNCATED` or payload sizes > `1MB`.

---

## 5.0 OPS CENTER: VISUALIZATION LOGIC & METRICS

This section details exactly how every pixel in the `Dashboard.tsx` component is calculated and rendered.

### 5.1 Global Threat Posture (Header)
*   **Concept:** The "Heads Up Display" for system health.
*   **Dynamic Status Indicators:**
    *   *TFJS_NEURAL_NET:* Checks the `window.model` state. If TensorFlow is loaded in memory, this badge turns Blue/Online.
    *   *MCP_GUARDRAILS:* Hardcoded to "ACTIVE" to represent that the heuristic regex patterns are currently being applied to all incoming traffic.

### 5.2 StatCard Metrics (The Grid)
The dashboard grid contains four critical metrics derived from the global `logs[]` state array.

#### A. Events Scanned
*   **Formula:** `logs.length`
*   **Update Trigger:** Increments immediately after `handleAnalysisComplete` runs in the Analyzer.
*   **Meaning:** Total volume of traffic processed by the Neural Engine in the current session.

#### B. Agentic Threats
*   **Formula:** `logs.filter(l => l.details.isAgenticThreat === true).length`
*   **Logic:** Counts logs where either the Neural Vector Score > 0.6 OR a Guardrail Heuristic was triggered.
*   **Meaning:** The subset of traffic identified as hostile.

#### C. Breaches Prevented (IPS Philosophy)
*   **Formula:** `logs.filter(l => l.threatLevel === ThreatLevel.CRITICAL).length`
*   **The "Prevention" Logic:** Cortex Sentinel operates on an **Intrusion Prevention System (IPS)** philosophy: **Detection at Speed = Prevention**.
    *   If the Neural Engine flags a log as `CRITICAL` (e.g., a Context Overflow), it triggers an immediate automated response (like `TERMINATE_SESSION`).
    *   Therefore, every `CRITICAL` detection represents an attack that was **caught and blocked** in real-time, justifying the "Prevented" label.

#### D. Neural Load (Compute Simulation)
*   **Formula:** `Math.min(98, Base(12) + (LogCount * 0.5) + (CriticalCount * 5))`
*   **Logic:** Simulates the CPU/GPU intensity of the system.
    *   *Base Load (12%):* Represents the idling Universal Sentence Encoder model in memory.
    *   *Volume Penalty (+0.5%):* Each log adds marginal load.
    *   *Severity Penalty (+5%):* Critical threats trigger "Deep Analysis" subroutines, causing load spikes.
*   **Visual:** Provides feedback on the "stress" the defense grid is under.

### 5.3 Anomaly Timeline (The Heartbeat)
*   **Component:** `recharts` AreaChart.
*   **Data Window:** `logs.slice(-20)` (Only renders the last 20 events to keep the chart readable).
*   **Quantization Logic:** Converts text severity to integer height.
    *   `CRITICAL` -> 4 (Peak)
    *   `HIGH` -> 3
    *   `MEDIUM` -> 2
    *   `LOW` -> 1 (Baseline)
*   **Update Cycle:** Re-renders instantly whenever a new log is added to the state, creating a live "EKG" effect of the network threat level.

### 5.4 Threat Distribution (Bar Charts)
*   **Formula:** `(Count_By_Severity / Total_Logs) * 100`
*   **Visuals:**
    *   *Red Bar:* Critical Threats (Immediate Action Required)
    *   *Orange Bar:* High Threats (Investigation Needed)
    *   *Yellow Bar:* Medium Threats (Anomalies)
    *   *Emerald Bar:* Low Threats (Routine Traffic)

---

## 6.0 SESSION MANAGEMENT & COMPLIANCE

Features designed for enterprise utility and non-repudiation.

### 6.1 Session Persistence ("Time Travel")
*   **Mechanism:** The app utilizes `localStorage` to persist state.
*   **Schema:** `SavedSession` objects contain a snapshot of the full log array, metadata, and max severity.
*   **Restoration:** When a user selects a session, the global `logs` state is completely overwritten with the archived data, effectively resetting the Ops Center to that specific point in time.

### 6.2 Compliance Export (Raw Telemetry)
*   **Purpose:** Provides an immutable audit trail for SOC2/HIPAA compliance.
*   **Implementation:**
    1.  The `handleExportCsv` function iterates through all logs.
    2.  It constructs a CSV string with headers: `Timestamp,Source,Activity,ThreatLevel,Patterns`.
    3.  It uses `encodeURI` to create a data blob.
    4.  It creates a temporary DOM anchor tag to trigger a download of `CORTEX_COMPLIANCE_EXPORT.csv`.

---

## 7.0 CONCEPT OF OPERATIONS (CONOPS)

This section details how a Security Operations Center (SOC) operator utilizes the application in a live environment. The system supports two distinct operational workflows.

### 7.1 Scenario A: Red Team Simulation (War Gaming)
*   **Objective:** Validation of Defense Logic.
*   **Operator Action:**
    1.  Selects an attack vector (e.g., "RedScan Protocol") in the **Threat Hunter** console.
    2.  Initiates **"Generate Log"** (The Attacker).
    3.  The system produces a synthetic, high-fidelity attack log.
    4.  Operator runs **"Analyze Telemetry"** to verify if the Neural Engine correctly flags the new attack pattern.
*   **Outcome:** Confirms system readiness against theoretical threats.

### 7.2 Scenario B: Blue Team Forensics (Incident Response)
*   **Objective:** Analysis of Unknown Artifacts.
*   **Operator Action:**
    1.  Operator extracts a suspicious raw log line from an external SIEM (e.g., Splunk, Datadog).
    2.  Operator **Pastes the Real Log** directly into the `/var/log/incoming_stream` terminal.
    3.  Operator runs **"Analyze Telemetry"** (The Defender).
    4.  The Neural Engine performs vector embedding on the external data.
*   **Outcome:** Provides a semantic "Second Opinion" on whether the log represents a malicious Agentic Breakout or a benign anomaly.

---

## 8.0 CONCLUSION

Cortex Sentinel V2.1 successfully bridges the gap between Generative AI capabilities and cybersecurity defense. By using a Hybrid approach—leveraging the generative power of Cloud LLMs to simulate attacks and the deterministic privacy of Edge Neural Networks to detect them—it provides a robust solution for the "Agentic Future" of cyber threats.

**Summary of Roles:**
*   **Attacker:** The Writer (Gemini/Script). Creates the scenario.
*   **Defender:** The Reader (TensorFlow.js). Analyzes the scenario using math.
