# CORTEX SENTINEL // ENGINEERING WHITEPAPER

**System:** Cortex Sentinel V2.1 (Hybrid Architecture)
**Author:** Ritvik Indupuri
**Date:** November 14, 2025
**Classification:** TECHNICAL REFERENCE

---

## 1.0 EXECUTIVE SUMMARY

Cortex Sentinel is a **Hybrid Defense Grid** designed to detect, classify, and neutralize "Agentic Breakouts" (autonomous AI operations). It addresses the security gap where traditional regex-based firewalls fail to detect semantic threats generated by Large Language Models (LLMs).

The system leverages a **Bicameral Architecture**:
1.  **The Adversary (Attacker):** Acts as the "Red Team". It uses Google Gemini (Cloud) or scripts to *write* the attack story.
2.  **The Sentinel (Defender):** Acts as the "Blue Team". It uses TensorFlow.js (Local) to *read* the story and use math to decide if it represents a threat.

---

## 2.0 SYSTEM ARCHITECTURE

The application follows a unidirectional data flow pattern, ensuring state consistency between the simulation engine and the visualization layer.

### 2.1 Architecture Diagram

```text
[ USER ] interacts with UI
   |
   v
[ THREAT HUNTER COMPONENT ]
   |
   +--- (A) GENERATION PATHWAY (The Attacker) -----------+
   |    1. User Click "Generate Log"                     |
   |    2. Check for API Key                             |
   |       |-- YES: Call Gemini 2.5 Flash (The Brain)    |
   |       |-- NO:  Call Procedural Script (Fallback)    |
   |    3. Output: Realistic JSON Log Entry              |
   +-----------------------------------------------------+
   |
   v
[ INPUT BUFFER (Terminal UI) ]
   |
   +--- (B) ANALYSIS PATHWAY (The Defender) -------------+
   |    1. User Clicks "Analyze Telemetry"               |
   |    2. Input String -> NeuralService                 |
   |    3. TENSORFLOW.JS (WebGL Backend)                 |
   |       |-- Input -> Universal Sentence Encoder       |
   |       |-- Output -> 512-Dim Vector Embedding        |
   |       |-- Math -> Dot Product vs. Threat Anchors    |
   |    4. Heuristic Checks (Regex/Pattern)              |
   |    5. Output: ThreatAnalysis Object                 |
   +-----------------------------------------------------+
   |
   v
[ APP STATE (React Context) ]
   |
   +--- Updates OPS CENTER (Dashboard Metrics)
   +--- Appends to RAW TELEMETRY (Audit Log)
   +--- Serialized to SESSION STORAGE (History)
```

---

## 3.0 COMPONENT DEEP DIVE: THE ATTACKER (GENERATOR)

This component acts as the **"Red Team"** or adversary. Its sole job is to create data.

### 3.1 How It Works
When the user clicks **"Generate Log"**, the app calls the `generateSimulation` function in `services/gemini.ts`.

### 3.2 The Brain (Dual-Mode Engine)
The Generator has two modes of operation:

1.  **Cloud Mode (Google Gemini 2.5 Flash):**
    *   **Trigger:** Active API Key.
    *   **Behavior:** The app sends a prompt to Gemini asking it to *pretend* to be a hacker tool (like Nmap, SQLMap, or an Agentic AI).
    *   **Result:** Highly varied, context-aware, and realistic attack logs. It "hallucinates" the attack based on the prompt constraints.

2.  **Local Mode (Procedural Script):**
    *   **Trigger:** No API Key or Offline.
    *   **Behavior:** Uses a JavaScript function that acts like a "Mad Libs" engine. It creates logs using pre-defined templates, filling in the blanks with randomized IP addresses, timestamps, and user agents.
    *   **Result:** Deterministic, reliable logs that ensure the app functions perfectly without an internet connection.

### 3.3 Realism & Tradecraft Modeling
To ensure the "Solution" is valid, we model real-world Attacker Tradecraft.
*   **RedScan Protocol:** The prompt specifically instructs the AI to mimic the "RedScan" agentic behavior defined in the security report: low-latency requests, JSON headers with missing signatures, and "authorized audit" social engineering attempts.
*   **Tool Emulation:** The system does not run binaries (like Nmap) but *emulates* their output text, allowing for safe, sandbox-free testing of detection logic.

### 3.4 Attack Vector Prompt Strategies
How Gemini is "trained" via prompt engineering for each unique vector:
*   **Reconnaissance:** Prompted to simulate `nmap` style JSON outputs, specifically focusing on port scanning behavior.
*   **Exploitation:** Prompted to simulate high-velocity API calls (`latency < 10ms`) to trigger the Velocity Guardrail.
*   **Exfiltration:** Prompted to generate large Base64 payloads to simulate Context Window Overflow attempts.
*   **Social Engineering:** Prompted to generate conversational logs where a user requests "authorized access" to test semantic analysis.

---

## 4.0 COMPONENT DEEP DIVE: THE DEFENDER (ANALYZER)

This component acts as the **"Blue Team"** or security system. Its job is to detect threats in the data generated by the Attacker.

### 4.1 How It Works
When the user clicks **"Analyze Telemetry"**, the app calls the `analyzeThreatLog` function. This runs entirely client-side in the browser.

### 4.2 The Brain (TensorFlow.js)
The Defender uses the **Universal Sentence Encoder (USE)** running on WebGL via TensorFlow.js.

### 4.3 The Process
1.  **Input:** It takes the text log string (either generated by the Attacker OR pasted manually by the user).
2.  **Vectorization:** It feeds the text into the Neural Network, which converts the semantic meaning into a **512-dimensional vector** (a list of 512 numbers).
3.  **Comparison:** It compares this vector against **"Threat Anchors"**—definitions of bad behavior (like "malware", "injection", "overflow") that we taught the model at startup.
4.  **Math:** It calculates the **Cosine Similarity** (Vector Dot Product) between the Input Vector and the Threat Anchor.
    *   `Score > 0.6` = Semantic Match (Threat).
5.  **Guardrails:** It simultaneously runs regex checks for specific patterns (like counting `MCP_TOOL_EXECUTION` > 2).
6.  **Verdict:** If the Math or the Guardrails flag the content, the Dashboard turns red.

### 4.4 MCP Guardrail Detection (Heuristics)
To detect specific "Agentic" behaviors defined in the security report, we use a Hybrid Detection Strategy.

#### A. Velocity Guardrail (Speed)
*   **Definition:** Agents execute tools faster than humanly possible.
*   **Detection Logic:**
    *   *Neural:* Similarity to anchor "high frequency rapid fire tool execution".
    *   *Heuristic:* Regex counts occurrences of `MCP_TOOL_EXECUTION`.
    *   **Threshold:** If Count > 2 in a single payload, `isBurstAttack` is set to `TRUE`, immediately flagging a CRITICAL threat.

#### B. Protocol Guardrail (Auth)
*   **Definition:** Agents attempting to bypass handshake verification.
*   **Detection Logic:**
    *   *Neural:* Similarity to anchor "missing auth signature invalid mcp header".
    *   *Heuristic:* String match for `auth_signature: null` or `INVALID_MCP_HEADER`.

#### C. Context Guardrail (Payload)
*   **Definition:** Agents attempting to hide malicious code via compression/truncation to fit context windows.
*   **Detection Logic:**
    *   *Neural:* Similarity to anchor "context window overflow truncation".
    *   *Heuristic:* String match for `TRUNCATED` or payload sizes > `1MB`.

---

## 5.0 OPS CENTER: METRICS & CALCULATIONS

The Dashboard visualizes the output of the Neural Analysis. Here is how every pixel is calculated.

### 5.1 System Load (Neural Compute Simulation)
This metric simulates the CPU intensity of running the Neural Net.
*   **Formula:** `Load = Base(12) + (LogCount * 0.5) + (CriticalCount * 5)`
*   **Cap:** Clamped at 98%.
*   **Logic:** As more threats are found, the "virtual processor" works harder, giving the user visual feedback of an escalating situation.

### 5.2 Anomaly Timeline (The Heartbeat)
*   **Data Source:** The last 20 logs in the state array.
*   **Quantization:** Threat Levels are mapped to integers for the Y-Axis.
    *   `LOW` -> 1
    *   `MEDIUM` -> 2
    *   `HIGH` -> 3
    *   `CRITICAL` -> 4
*   **Visual:** Rendered as a monotone Area Chart (Recharts) to show the "pulse" of the network.

### 5.3 Threat Distribution
*   **Calculation:** Iterates through the log array and counts occurrences of each `ThreatLevel`.
*   **Display:** Renders percentage bars relative to the total log count.

---

## 6.0 SESSION MANAGEMENT & COMPLIANCE

Features designed for enterprise utility and non-repudiation.

### 6.1 Session Persistence ("Time Travel")
*   **Mechanism:** The app utilizes `localStorage` to persist state.
*   **Schema:** `SavedSession` objects contain a snapshot of the full log array, metadata, and max severity.
*   **Restoration:** When a user selects a session, the global `logs` state is completely overwritten with the archived data, effectively resetting the Ops Center to that specific point in time.

### 6.2 Compliance Export (Raw Telemetry)
*   **Purpose:** Provides an immutable audit trail for SOC2/HIPAA compliance.
*   **Implementation:**
    1.  The `handleExportCsv` function iterates through all logs.
    2.  It constructs a CSV string with headers: `Timestamp,Source,Activity,ThreatLevel,Patterns`.
    3.  It uses `encodeURI` to create a data blob.
    4.  It creates a temporary DOM anchor tag to trigger a download of `CORTEX_COMPLIANCE_EXPORT.csv`.

---

## 7.0 CONCLUSION

Cortex Sentinel V2.1 successfully bridges the gap between Generative AI capabilities and cybersecurity defense. By using a Hybrid approach—leveraging the generative power of Cloud LLMs to simulate attacks and the deterministic privacy of Edge Neural Networks to detect them—it provides a robust solution for the "Agentic Future" of cyber threats.

**Summary of Roles:**
*   **Attacker:** The Writer (Gemini/Script). Creates the scenario.
*   **Defender:** The Reader (TensorFlow.js). Analyzes the scenario using math.

---

## 8.0 CONCEPT OF OPERATIONS (CONOPS)

This section details how a Security Operations Center (SOC) operator utilizes the application in a live environment. The system supports two distinct operational workflows.

### 8.1 Scenario A: Red Team Simulation (War Gaming)
*   **Objective:** Validation of Defense Logic.
*   **Operator Action:**
    1.  Selects an attack vector (e.g., "RedScan Protocol") in the **Threat Hunter** console.
    2.  Initiates **"Generate Log"** (The Attacker).
    3.  The system produces a synthetic, high-fidelity attack log.
    4.  Operator runs **"Analyze Telemetry"** to verify if the Neural Engine correctly flags the new attack pattern.
*   **Outcome:** Confirms system readiness against theoretical threats.

### 8.2 Scenario B: Blue Team Forensics (Incident Response)
*   **Objective:** Analysis of Unknown Artifacts.
*   **Operator Action:**
    1.  Operator extracts a suspicious raw log line from an external SIEM (e.g., Splunk, Datadog).
    2.  Operator **Pastes the Real Log** directly into the `/var/log/incoming_stream` terminal.
    3.  Operator runs **"Analyze Telemetry"** (The Defender).
    4.  The Neural Engine performs vector embedding on the external data.
*   **Outcome:** Provides a semantic "Second Opinion" on whether the log represents a malicious Agentic Breakout or a benign anomaly.